// File automatically generated by build.rs.
// Changes made to this file will not be saved.
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct RtsStruct<const N: usize> {
    /// size: 4, offset: 0x0, type: i32
    pub other_data: i32,
    pub _padother_data: [u8; 4 - 0 - core::mem::size_of::<i32>()],
    /// size: 4, offset: 0x4, type: array<u32>
    pub the_array: [u32; N],
}
impl<const N: usize> RtsStruct<N> {
    pub fn new(other_data: i32, the_array: [u32; N]) -> Self {
        Self {
            other_data,
            _padother_data: [0; 4 - 0 - core::mem::size_of::<i32>()],
            the_array,
        }
    }
}
unsafe impl<const N: usize> bytemuck::Zeroable for RtsStruct<N> {}
unsafe impl<const N: usize> bytemuck::Pod for RtsStruct<N> {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct RtsStructInit<const N: usize> {
    pub other_data: i32,
    pub the_array: [u32; N],
}
impl<const N: usize> RtsStructInit<N> {
    pub const fn const_into(&self) -> RtsStruct<N> {
        let init = self;
        RtsStruct {
            other_data: init.other_data,
            _padother_data: [0; 4 - 0 - core::mem::size_of::<i32>()],
            the_array: init.the_array,
        }
    }
}
impl<const N: usize> From<RtsStructInit<N>> for RtsStruct<N> {
    fn from(init: RtsStructInit<N>) -> Self {
        Self {
            other_data: init.other_data,
            _padother_data: [0; 4 - 0 - core::mem::size_of::<i32>()],
            the_array: init.the_array,
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < RtsStruct < 1 > > () == 8,
    "size of RtsStruct does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(RtsStruct < 1 >, other_data) == 0,
    "offset of RtsStruct.other_data does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(RtsStruct < 1 >, the_array) == 4,
    "offset of RtsStruct.the_array does not match WGSL"
);
#[repr(C, align(4))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Scalars {
    /// size: 4, offset: 0x0, type: u32
    pub a: u32,
    pub _pada: [u8; 4 - 0 - core::mem::size_of::<u32>()],
    /// size: 4, offset: 0x4, type: i32
    pub b: i32,
    pub _padb: [u8; 8 - 4 - core::mem::size_of::<i32>()],
    /// size: 4, offset: 0x8, type: f32
    pub c: f32,
    pub _padc: [u8; 12 - 8 - core::mem::size_of::<f32>()],
}
impl Scalars {
    pub fn new(a: u32, b: i32, c: f32) -> Self {
        Self {
            a,
            _pada: [0; 4 - 0 - core::mem::size_of::<u32>()],
            b,
            _padb: [0; 8 - 4 - core::mem::size_of::<i32>()],
            c,
            _padc: [0; 12 - 8 - core::mem::size_of::<f32>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for Scalars {}
unsafe impl bytemuck::Pod for Scalars {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct ScalarsInit {
    pub a: u32,
    pub b: i32,
    pub c: f32,
}
impl ScalarsInit {
    pub const fn const_into(&self) -> Scalars {
        let init = self;
        Scalars {
            a: init.a,
            _pada: [0; 4 - 0 - core::mem::size_of::<u32>()],
            b: init.b,
            _padb: [0; 8 - 4 - core::mem::size_of::<i32>()],
            c: init.c,
            _padc: [0; 12 - 8 - core::mem::size_of::<f32>()],
        }
    }
}
impl From<ScalarsInit> for Scalars {
    fn from(init: ScalarsInit) -> Self {
        Self {
            a: init.a,
            _pada: [0; 4 - 0 - core::mem::size_of::<u32>()],
            b: init.b,
            _padb: [0; 8 - 4 - core::mem::size_of::<i32>()],
            c: init.c,
            _padc: [0; 12 - 8 - core::mem::size_of::<f32>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < Scalars > () == 12, "size of Scalars does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(Scalars, a) == 0, "offset of Scalars.a does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(Scalars, b) == 4, "offset of Scalars.b does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(Scalars, c) == 8, "offset of Scalars.c does not match WGSL"
);
#[repr(C, align(16))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsU32 {
    /// size: 8, offset: 0x0, type: vec2<u32>
    pub a: glam::UVec2,
    pub _pada: [u8; 16 - 0 - core::mem::size_of::<glam::UVec2>()],
    /// size: 12, offset: 0x10, type: vec3<u32>
    pub b: [u32; 4],
    pub _padb: [u8; 32 - 16 - core::mem::size_of::<[u32; 4]>()],
    /// size: 16, offset: 0x20, type: vec4<u32>
    pub c: glam::UVec4,
    pub _padc: [u8; 48 - 32 - core::mem::size_of::<glam::UVec4>()],
}
impl VectorsU32 {
    pub fn new(a: glam::UVec2, b: [u32; 4], c: glam::UVec4) -> Self {
        Self {
            a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::UVec2>()],
            b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[u32; 4]>()],
            c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::UVec4>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for VectorsU32 {}
unsafe impl bytemuck::Pod for VectorsU32 {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsU32Init {
    pub a: glam::UVec2,
    pub b: [u32; 4],
    pub c: glam::UVec4,
}
impl VectorsU32Init {
    pub const fn const_into(&self) -> VectorsU32 {
        let init = self;
        VectorsU32 {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::UVec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[u32; 4]>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::UVec4>()],
        }
    }
}
impl From<VectorsU32Init> for VectorsU32 {
    fn from(init: VectorsU32Init) -> Self {
        Self {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::UVec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[u32; 4]>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::UVec4>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < VectorsU32 > () == 48, "size of VectorsU32 does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsU32, a) == 0,
    "offset of VectorsU32.a does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsU32, b) == 16,
    "offset of VectorsU32.b does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsU32, c) == 32,
    "offset of VectorsU32.c does not match WGSL"
);
#[repr(C, align(16))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsI32 {
    /// size: 8, offset: 0x0, type: vec2<i32>
    pub a: glam::IVec2,
    pub _pada: [u8; 16 - 0 - core::mem::size_of::<glam::IVec2>()],
    /// size: 12, offset: 0x10, type: vec3<i32>
    pub b: [i32; 4],
    pub _padb: [u8; 32 - 16 - core::mem::size_of::<[i32; 4]>()],
    /// size: 16, offset: 0x20, type: vec4<i32>
    pub c: glam::IVec4,
    pub _padc: [u8; 48 - 32 - core::mem::size_of::<glam::IVec4>()],
}
impl VectorsI32 {
    pub fn new(a: glam::IVec2, b: [i32; 4], c: glam::IVec4) -> Self {
        Self {
            a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::IVec2>()],
            b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[i32; 4]>()],
            c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::IVec4>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for VectorsI32 {}
unsafe impl bytemuck::Pod for VectorsI32 {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsI32Init {
    pub a: glam::IVec2,
    pub b: [i32; 4],
    pub c: glam::IVec4,
}
impl VectorsI32Init {
    pub const fn const_into(&self) -> VectorsI32 {
        let init = self;
        VectorsI32 {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::IVec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[i32; 4]>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::IVec4>()],
        }
    }
}
impl From<VectorsI32Init> for VectorsI32 {
    fn from(init: VectorsI32Init) -> Self {
        Self {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::IVec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<[i32; 4]>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::IVec4>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < VectorsI32 > () == 48, "size of VectorsI32 does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsI32, a) == 0,
    "offset of VectorsI32.a does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsI32, b) == 16,
    "offset of VectorsI32.b does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsI32, c) == 32,
    "offset of VectorsI32.c does not match WGSL"
);
#[repr(C, align(16))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsF32 {
    /// size: 8, offset: 0x0, type: vec2<f32>
    pub a: glam::Vec2,
    pub _pada: [u8; 16 - 0 - core::mem::size_of::<glam::Vec2>()],
    /// size: 12, offset: 0x10, type: vec3<f32>
    pub b: glam::Vec3A,
    pub _padb: [u8; 32 - 16 - core::mem::size_of::<glam::Vec3A>()],
    /// size: 16, offset: 0x20, type: vec4<f32>
    pub c: glam::Vec4,
    pub _padc: [u8; 48 - 32 - core::mem::size_of::<glam::Vec4>()],
}
impl VectorsF32 {
    pub fn new(a: glam::Vec2, b: glam::Vec3A, c: glam::Vec4) -> Self {
        Self {
            a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::Vec2>()],
            b,
            _padb: [0; 32 - 16 - core::mem::size_of::<glam::Vec3A>()],
            c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for VectorsF32 {}
unsafe impl bytemuck::Pod for VectorsF32 {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VectorsF32Init {
    pub a: glam::Vec2,
    pub b: glam::Vec3A,
    pub c: glam::Vec4,
}
impl VectorsF32Init {
    pub const fn const_into(&self) -> VectorsF32 {
        let init = self;
        VectorsF32 {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::Vec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<glam::Vec3A>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
impl From<VectorsF32Init> for VectorsF32 {
    fn from(init: VectorsF32Init) -> Self {
        Self {
            a: init.a,
            _pada: [0; 16 - 0 - core::mem::size_of::<glam::Vec2>()],
            b: init.b,
            _padb: [0; 32 - 16 - core::mem::size_of::<glam::Vec3A>()],
            c: init.c,
            _padc: [0; 48 - 32 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < VectorsF32 > () == 48, "size of VectorsF32 does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsF32, a) == 0,
    "offset of VectorsF32.a does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsF32, b) == 16,
    "offset of VectorsF32.b does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(VectorsF32, c) == 32,
    "offset of VectorsF32.c does not match WGSL"
);
#[repr(C, align(16))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct MatricesF32 {
    /// size: 64, offset: 0x0, type: mat4x4<f32>
    pub a: glam::Mat4,
    pub _pada: [u8; 64 - 0 - core::mem::size_of::<glam::Mat4>()],
    /// size: 64, offset: 0x40, type: mat4x3<f32>
    pub b: [[f32; 4]; 4],
    pub _padb: [u8; 128 - 64 - core::mem::size_of::<[[f32; 4]; 4]>()],
    /// size: 32, offset: 0x80, type: mat4x2<f32>
    pub c: [[f32; 4]; 2],
    pub _padc: [u8; 160 - 128 - core::mem::size_of::<[[f32; 4]; 2]>()],
    /// size: 48, offset: 0xA0, type: mat3x4<f32>
    pub d: [[f32; 3]; 4],
    pub _padd: [u8; 208 - 160 - core::mem::size_of::<[[f32; 3]; 4]>()],
    /// size: 48, offset: 0xD0, type: mat3x3<f32>
    pub e: glam::Mat3A,
    pub _pade: [u8; 256 - 208 - core::mem::size_of::<glam::Mat3A>()],
    /// size: 24, offset: 0x100, type: mat3x2<f32>
    pub f: [[f32; 3]; 2],
    pub _padf: [u8; 288 - 256 - core::mem::size_of::<[[f32; 3]; 2]>()],
    /// size: 32, offset: 0x120, type: mat2x4<f32>
    pub g: [[f32; 2]; 4],
    pub _padg: [u8; 320 - 288 - core::mem::size_of::<[[f32; 2]; 4]>()],
    /// size: 32, offset: 0x140, type: mat2x3<f32>
    pub h: [[f32; 2]; 4],
    pub _padh: [u8; 352 - 320 - core::mem::size_of::<[[f32; 2]; 4]>()],
    /// size: 16, offset: 0x160, type: mat2x2<f32>
    pub i: [[f32; 2]; 2],
    pub _padi: [u8; 368 - 352 - core::mem::size_of::<[[f32; 2]; 2]>()],
}
impl MatricesF32 {
    pub fn new(
        a: glam::Mat4,
        b: [[f32; 4]; 4],
        c: [[f32; 4]; 2],
        d: [[f32; 3]; 4],
        e: glam::Mat3A,
        f: [[f32; 3]; 2],
        g: [[f32; 2]; 4],
        h: [[f32; 2]; 4],
        i: [[f32; 2]; 2],
    ) -> Self {
        Self {
            a,
            _pada: [0; 64 - 0 - core::mem::size_of::<glam::Mat4>()],
            b,
            _padb: [0; 128 - 64 - core::mem::size_of::<[[f32; 4]; 4]>()],
            c,
            _padc: [0; 160 - 128 - core::mem::size_of::<[[f32; 4]; 2]>()],
            d,
            _padd: [0; 208 - 160 - core::mem::size_of::<[[f32; 3]; 4]>()],
            e,
            _pade: [0; 256 - 208 - core::mem::size_of::<glam::Mat3A>()],
            f,
            _padf: [0; 288 - 256 - core::mem::size_of::<[[f32; 3]; 2]>()],
            g,
            _padg: [0; 320 - 288 - core::mem::size_of::<[[f32; 2]; 4]>()],
            h,
            _padh: [0; 352 - 320 - core::mem::size_of::<[[f32; 2]; 4]>()],
            i,
            _padi: [0; 368 - 352 - core::mem::size_of::<[[f32; 2]; 2]>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for MatricesF32 {}
unsafe impl bytemuck::Pod for MatricesF32 {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct MatricesF32Init {
    pub a: glam::Mat4,
    pub b: [[f32; 4]; 4],
    pub c: [[f32; 4]; 2],
    pub d: [[f32; 3]; 4],
    pub e: glam::Mat3A,
    pub f: [[f32; 3]; 2],
    pub g: [[f32; 2]; 4],
    pub h: [[f32; 2]; 4],
    pub i: [[f32; 2]; 2],
}
impl MatricesF32Init {
    pub const fn const_into(&self) -> MatricesF32 {
        let init = self;
        MatricesF32 {
            a: init.a,
            _pada: [0; 64 - 0 - core::mem::size_of::<glam::Mat4>()],
            b: init.b,
            _padb: [0; 128 - 64 - core::mem::size_of::<[[f32; 4]; 4]>()],
            c: init.c,
            _padc: [0; 160 - 128 - core::mem::size_of::<[[f32; 4]; 2]>()],
            d: init.d,
            _padd: [0; 208 - 160 - core::mem::size_of::<[[f32; 3]; 4]>()],
            e: init.e,
            _pade: [0; 256 - 208 - core::mem::size_of::<glam::Mat3A>()],
            f: init.f,
            _padf: [0; 288 - 256 - core::mem::size_of::<[[f32; 3]; 2]>()],
            g: init.g,
            _padg: [0; 320 - 288 - core::mem::size_of::<[[f32; 2]; 4]>()],
            h: init.h,
            _padh: [0; 352 - 320 - core::mem::size_of::<[[f32; 2]; 4]>()],
            i: init.i,
            _padi: [0; 368 - 352 - core::mem::size_of::<[[f32; 2]; 2]>()],
        }
    }
}
impl From<MatricesF32Init> for MatricesF32 {
    fn from(init: MatricesF32Init) -> Self {
        Self {
            a: init.a,
            _pada: [0; 64 - 0 - core::mem::size_of::<glam::Mat4>()],
            b: init.b,
            _padb: [0; 128 - 64 - core::mem::size_of::<[[f32; 4]; 4]>()],
            c: init.c,
            _padc: [0; 160 - 128 - core::mem::size_of::<[[f32; 4]; 2]>()],
            d: init.d,
            _padd: [0; 208 - 160 - core::mem::size_of::<[[f32; 3]; 4]>()],
            e: init.e,
            _pade: [0; 256 - 208 - core::mem::size_of::<glam::Mat3A>()],
            f: init.f,
            _padf: [0; 288 - 256 - core::mem::size_of::<[[f32; 3]; 2]>()],
            g: init.g,
            _padg: [0; 320 - 288 - core::mem::size_of::<[[f32; 2]; 4]>()],
            h: init.h,
            _padh: [0; 352 - 320 - core::mem::size_of::<[[f32; 2]; 4]>()],
            i: init.i,
            _padi: [0; 368 - 352 - core::mem::size_of::<[[f32; 2]; 2]>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < MatricesF32 > () == 368,
    "size of MatricesF32 does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, a) == 0,
    "offset of MatricesF32.a does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, b) == 64,
    "offset of MatricesF32.b does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, c) == 128,
    "offset of MatricesF32.c does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, d) == 160,
    "offset of MatricesF32.d does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, e) == 208,
    "offset of MatricesF32.e does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, f) == 256,
    "offset of MatricesF32.f does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, g) == 288,
    "offset of MatricesF32.g does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, h) == 320,
    "offset of MatricesF32.h does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(MatricesF32, i) == 352,
    "offset of MatricesF32.i does not match WGSL"
);
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct VertexInput {
    pub position: glam::Vec3A,
}
impl VertexInput {
    pub fn new(position: glam::Vec3A) -> Self {
        Self { position }
    }
}
unsafe impl bytemuck::Zeroable for VertexInput {}
unsafe impl bytemuck::Pod for VertexInput {}
#[repr(C, align(16))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Uniforms {
    /// size: 16, offset: 0x0, type: vec4<f32>
    pub color_rgb: glam::Vec4,
    pub _padcolor_rgb: [u8; 16 - 0 - core::mem::size_of::<glam::Vec4>()],
}
impl Uniforms {
    pub fn new(color_rgb: glam::Vec4) -> Self {
        Self {
            color_rgb,
            _padcolor_rgb: [0; 16 - 0 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for Uniforms {}
unsafe impl bytemuck::Pod for Uniforms {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct UniformsInit {
    pub color_rgb: glam::Vec4,
}
impl UniformsInit {
    pub const fn const_into(&self) -> Uniforms {
        let init = self;
        Uniforms {
            color_rgb: init.color_rgb,
            _padcolor_rgb: [0; 16 - 0 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
impl From<UniformsInit> for Uniforms {
    fn from(init: UniformsInit) -> Self {
        Self {
            color_rgb: init.color_rgb,
            _padcolor_rgb: [0; 16 - 0 - core::mem::size_of::<glam::Vec4>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < Uniforms > () == 16, "size of Uniforms does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(Uniforms, color_rgb) == 0,
    "offset of Uniforms.color_rgb does not match WGSL"
);
#[repr(C, align(4))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct ScalingModeData {
    /// size: 4, offset: 0x0, type: i32
    pub kind: i32,
    pub _padkind: [u8; 4 - 0 - core::mem::size_of::<i32>()],
    /// size: 4, offset: 0x4, type: f32
    pub logical_offset: f32,
    pub _padlogical_offset: [u8; 8 - 4 - core::mem::size_of::<f32>()],
    /// size: 4, offset: 0x8, type: f32
    pub coord_offset: f32,
    pub _padcoord_offset: [u8; 12 - 8 - core::mem::size_of::<f32>()],
    /// size: 4, offset: 0xC, type: f32
    pub base_value: f32,
    pub _padbase_value: [u8; 16 - 12 - core::mem::size_of::<f32>()],
}
impl ScalingModeData {
    pub fn new(
        kind: i32,
        logical_offset: f32,
        coord_offset: f32,
        base_value: f32,
    ) -> Self {
        Self {
            kind,
            _padkind: [0; 4 - 0 - core::mem::size_of::<i32>()],
            logical_offset,
            _padlogical_offset: [0; 8 - 4 - core::mem::size_of::<f32>()],
            coord_offset,
            _padcoord_offset: [0; 12 - 8 - core::mem::size_of::<f32>()],
            base_value,
            _padbase_value: [0; 16 - 12 - core::mem::size_of::<f32>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for ScalingModeData {}
unsafe impl bytemuck::Pod for ScalingModeData {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct ScalingModeDataInit {
    pub kind: i32,
    pub logical_offset: f32,
    pub coord_offset: f32,
    pub base_value: f32,
}
impl ScalingModeDataInit {
    pub const fn const_into(&self) -> ScalingModeData {
        let init = self;
        ScalingModeData {
            kind: init.kind,
            _padkind: [0; 4 - 0 - core::mem::size_of::<i32>()],
            logical_offset: init.logical_offset,
            _padlogical_offset: [0; 8 - 4 - core::mem::size_of::<f32>()],
            coord_offset: init.coord_offset,
            _padcoord_offset: [0; 12 - 8 - core::mem::size_of::<f32>()],
            base_value: init.base_value,
            _padbase_value: [0; 16 - 12 - core::mem::size_of::<f32>()],
        }
    }
}
impl From<ScalingModeDataInit> for ScalingModeData {
    fn from(init: ScalingModeDataInit) -> Self {
        Self {
            kind: init.kind,
            _padkind: [0; 4 - 0 - core::mem::size_of::<i32>()],
            logical_offset: init.logical_offset,
            _padlogical_offset: [0; 8 - 4 - core::mem::size_of::<f32>()],
            coord_offset: init.coord_offset,
            _padcoord_offset: [0; 12 - 8 - core::mem::size_of::<f32>()],
            base_value: init.base_value,
            _padbase_value: [0; 16 - 12 - core::mem::size_of::<f32>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < ScalingModeData > () == 16,
    "size of ScalingModeData does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(ScalingModeData, kind) == 0,
    "offset of ScalingModeData.kind does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(ScalingModeData, logical_offset) == 4,
    "offset of ScalingModeData.logical_offset does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(ScalingModeData, coord_offset) == 8,
    "offset of ScalingModeData.coord_offset does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(ScalingModeData, base_value) == 12,
    "offset of ScalingModeData.base_value does not match WGSL"
);
#[repr(C, align(8))]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct UniformsData {
    /// size: 16, offset: 0x0, type: struct
    pub x_scaling_mode: ScalingModeData,
    pub _padx_scaling_mode: [u8; 16 - 0 - core::mem::size_of::<ScalingModeData>()],
    /// size: 16, offset: 0x10, type: struct
    pub y_scaling_mode: ScalingModeData,
    pub _pady_scaling_mode: [u8; 32 - 16 - core::mem::size_of::<ScalingModeData>()],
    /// size: 16, offset: 0x20, type: mat2x2<f32>
    pub logical_view_matrix: [[f32; 2]; 2],
    pub _padlogical_view_matrix: [u8; 48 - 32 - core::mem::size_of::<[[f32; 2]; 2]>()],
    /// size: 8, offset: 0x30, type: vec2<f32>
    pub logical_space_center_point: glam::Vec2,
    pub _padlogical_space_center_point: [u8; 56 - 48
        - core::mem::size_of::<glam::Vec2>()],
}
impl UniformsData {
    pub fn new(
        x_scaling_mode: ScalingModeData,
        y_scaling_mode: ScalingModeData,
        logical_view_matrix: [[f32; 2]; 2],
        logical_space_center_point: glam::Vec2,
    ) -> Self {
        Self {
            x_scaling_mode,
            _padx_scaling_mode: [0; 16 - 0 - core::mem::size_of::<ScalingModeData>()],
            y_scaling_mode,
            _pady_scaling_mode: [0; 32 - 16 - core::mem::size_of::<ScalingModeData>()],
            logical_view_matrix,
            _padlogical_view_matrix: [0; 48 - 32
                - core::mem::size_of::<[[f32; 2]; 2]>()],
            logical_space_center_point,
            _padlogical_space_center_point: [0; 56 - 48
                - core::mem::size_of::<glam::Vec2>()],
        }
    }
}
unsafe impl bytemuck::Zeroable for UniformsData {}
unsafe impl bytemuck::Pod for UniformsData {}
#[repr(C)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct UniformsDataInit {
    pub x_scaling_mode: ScalingModeData,
    pub y_scaling_mode: ScalingModeData,
    pub logical_view_matrix: [[f32; 2]; 2],
    pub logical_space_center_point: glam::Vec2,
}
impl UniformsDataInit {
    pub const fn const_into(&self) -> UniformsData {
        let init = self;
        UniformsData {
            x_scaling_mode: init.x_scaling_mode,
            _padx_scaling_mode: [0; 16 - 0 - core::mem::size_of::<ScalingModeData>()],
            y_scaling_mode: init.y_scaling_mode,
            _pady_scaling_mode: [0; 32 - 16 - core::mem::size_of::<ScalingModeData>()],
            logical_view_matrix: init.logical_view_matrix,
            _padlogical_view_matrix: [0; 48 - 32
                - core::mem::size_of::<[[f32; 2]; 2]>()],
            logical_space_center_point: init.logical_space_center_point,
            _padlogical_space_center_point: [0; 56 - 48
                - core::mem::size_of::<glam::Vec2>()],
        }
    }
}
impl From<UniformsDataInit> for UniformsData {
    fn from(init: UniformsDataInit) -> Self {
        Self {
            x_scaling_mode: init.x_scaling_mode,
            _padx_scaling_mode: [0; 16 - 0 - core::mem::size_of::<ScalingModeData>()],
            y_scaling_mode: init.y_scaling_mode,
            _pady_scaling_mode: [0; 32 - 16 - core::mem::size_of::<ScalingModeData>()],
            logical_view_matrix: init.logical_view_matrix,
            _padlogical_view_matrix: [0; 48 - 32
                - core::mem::size_of::<[[f32; 2]; 2]>()],
            logical_space_center_point: init.logical_space_center_point,
            _padlogical_space_center_point: [0; 56 - 48
                - core::mem::size_of::<glam::Vec2>()],
        }
    }
}
const _: () = assert!(
    std::mem::size_of:: < UniformsData > () == 56,
    "size of UniformsData does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(UniformsData, x_scaling_mode) == 0,
    "offset of UniformsData.x_scaling_mode does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(UniformsData, y_scaling_mode) == 16,
    "offset of UniformsData.y_scaling_mode does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(UniformsData, logical_view_matrix) == 32,
    "offset of UniformsData.logical_view_matrix does not match WGSL"
);
const _: () = assert!(
    memoffset::offset_of!(UniformsData, logical_space_center_point) == 48,
    "offset of UniformsData.logical_space_center_point does not match WGSL"
);
pub mod bind_groups {
    #[derive(Debug)]
    pub struct BindGroup0(wgpu::BindGroup);
    #[derive(Debug)]
    pub struct BindGroupLayout0<'a> {
        pub rts: wgpu::BufferBinding<'a>,
        pub color_texture: &'a wgpu::TextureView,
        pub color_sampler: &'a wgpu::Sampler,
    }
    const LAYOUT_DESCRIPTOR0: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
        label: None,
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 3,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage {
                        read_only: false,
                    },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    sample_type: wgpu::TextureSampleType::Float {
                        filterable: true,
                    },
                    view_dimension: wgpu::TextureViewDimension::D2,
                    multisampled: false,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
        ],
    };
    impl BindGroup0 {
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout0) -> Self {
            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0);
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        layout: &bind_group_layout,
                        entries: &[
                            wgpu::BindGroupEntry {
                                binding: 3,
                                resource: wgpu::BindingResource::Buffer(bindings.rts),
                            },
                            wgpu::BindGroupEntry {
                                binding: 0,
                                resource: wgpu::BindingResource::TextureView(
                                    bindings.color_texture,
                                ),
                            },
                            wgpu::BindGroupEntry {
                                binding: 1,
                                resource: wgpu::BindingResource::Sampler(
                                    bindings.color_sampler,
                                ),
                            },
                        ],
                        label: None,
                    },
                );
            Self(bind_group)
        }
        pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
            render_pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct BindGroup1(wgpu::BindGroup);
    #[derive(Debug)]
    pub struct BindGroupLayout1<'a> {
        pub uniforms: wgpu::BufferBinding<'a>,
    }
    const LAYOUT_DESCRIPTOR1: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
        label: None,
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    };
    impl BindGroup1 {
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout1) -> Self {
            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1);
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        layout: &bind_group_layout,
                        entries: &[
                            wgpu::BindGroupEntry {
                                binding: 0,
                                resource: wgpu::BindingResource::Buffer(bindings.uniforms),
                            },
                        ],
                        label: None,
                    },
                );
            Self(bind_group)
        }
        pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
            render_pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug, Copy, Clone)]
    pub struct BindGroups<'a> {
        pub bind_group0: &'a BindGroup0,
        pub bind_group1: &'a BindGroup1,
    }
    impl<'a> BindGroups<'a> {
        pub fn set(&self, pass: &mut wgpu::RenderPass<'a>) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
}
pub fn set_bind_groups<'a>(
    pass: &mut wgpu::RenderPass<'a>,
    bind_group0: &'a bind_groups::BindGroup0,
    bind_group1: &'a bind_groups::BindGroup1,
) {
    bind_group0.set(pass);
    bind_group1.set(pass);
}
impl VertexInput {
    pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [
        wgpu::VertexAttribute {
            format: wgpu::VertexFormat::Float32x3,
            offset: memoffset::offset_of!(VertexInput, position) as u64,
            shader_location: 0,
        },
    ];
    pub const fn vertex_buffer_layout(
        step_mode: wgpu::VertexStepMode,
    ) -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<VertexInput>() as u64,
            step_mode,
            attributes: &VertexInput::VERTEX_ATTRIBUTES,
        }
    }
}
pub const ENTRY_VS_MAIN: &str = "vs_main";
pub const ENTRY_FS_MAIN: &str = "fs_main";
#[derive(Debug)]
pub struct VertexEntry<const N: usize> {
    entry_point: &'static str,
    buffers: [wgpu::VertexBufferLayout<'static>; N],
}
pub fn vertex_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a VertexEntry<N>,
) -> wgpu::VertexState<'a> {
    wgpu::VertexState {
        module,
        entry_point: entry.entry_point,
        buffers: &entry.buffers,
    }
}
pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
    VertexEntry {
        entry_point: ENTRY_VS_MAIN,
        buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
    }
}
pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {
    let source = std::borrow::Cow::Borrowed(include_str!("shader.wgsl"));
    device
        .create_shader_module(wgpu::ShaderModuleDescriptor {
            label: None,
            source: wgpu::ShaderSource::Wgsl(source),
        })
}
pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device
        .create_pipeline_layout(
            &wgpu::PipelineLayoutDescriptor {
                label: None,
                bind_group_layouts: &[
                    &bind_groups::BindGroup0::get_bind_group_layout(device),
                    &bind_groups::BindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            },
        )
}
