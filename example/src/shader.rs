// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.7.0
// Changes made to this file will not be saved.
// SourceHash: 6f469152513ffb30656f1e8a34dc974a59e090971e235acd89be6ecbd333d8f4

#![allow(unused, non_snake_case, non_camel_case_types)]
mod _root {
    pub use super::*;
    const _: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
}
pub mod reachme {
    use super::{_root, _root::*};
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct rtsStruct<const N: usize> {
        /// size: 4, offset: 0x0, type: `i32`
        pub other_data: i32,
        /// size: 4, offset: 0x4, type: `array<u32>`
        pub the_array: [u32; N],
    }
    pub const fn rtsStruct<const N: usize>(
        other_data: i32,
        the_array: [u32; N],
    ) -> rtsStruct<N> {
        rtsStruct { other_data, the_array }
    }
    unsafe impl<const N: usize> bytemuck::Zeroable for rtsStruct<N> {}
    unsafe impl<const N: usize> bytemuck::Pod for rtsStruct<N> {}
    const _: () = {
        assert!(std::mem::offset_of!(rtsStruct < 1 >, other_data) == 0);
        assert!(std::mem::offset_of!(rtsStruct < 1 >, the_array) == 4);
        assert!(std::mem::size_of:: < rtsStruct < 1 > > () == 8);
    };
}
pub mod types {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Scalars {
        /// size: 4, offset: 0x0, type: `u32`
        pub a: u32,
        /// size: 4, offset: 0x4, type: `i32`
        pub b: i32,
        /// size: 4, offset: 0x8, type: `f32`
        pub c: f32,
    }
    impl Scalars {
        pub const fn new(a: u32, b: i32, c: f32) -> Self {
            Self { a, b, c }
        }
    }
    unsafe impl bytemuck::Zeroable for Scalars {}
    unsafe impl bytemuck::Pod for Scalars {}
    const _: () = {
        assert!(std::mem::offset_of!(Scalars, a) == 0);
        assert!(std::mem::offset_of!(Scalars, b) == 4);
        assert!(std::mem::offset_of!(Scalars, c) == 8);
        assert!(std::mem::size_of:: < Scalars > () == 12);
    };
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsU32 {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub a: [u32; 2],
        pub _pad_a: [u8; 0x10 - core::mem::size_of::<[u32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<u32>`
        pub b: [u32; 4],
        /// size: 16, offset: 0x20, type: `vec4<u32>`
        pub c: [u32; 4],
    }
    impl VectorsU32 {
        pub const fn new(a: [u32; 2], b: [u32; 4], c: [u32; 4]) -> Self {
            Self {
                a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                b,
                c,
            }
        }
    }
    unsafe impl bytemuck::Zeroable for VectorsU32 {}
    unsafe impl bytemuck::Pod for VectorsU32 {}
    const _: () = {
        assert!(std::mem::offset_of!(VectorsU32, a) == 0);
        assert!(std::mem::offset_of!(VectorsU32, b) == 16);
        assert!(std::mem::offset_of!(VectorsU32, c) == 32);
        assert!(std::mem::size_of:: < VectorsU32 > () == 48);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsU32Init {
        pub a: [u32; 2],
        pub b: [u32; 4],
        pub c: [u32; 4],
    }
    impl VectorsU32Init {
        pub const fn const_into(&self) -> VectorsU32 {
            VectorsU32 {
                a: self.a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                b: self.b,
                c: self.c,
            }
        }
    }
    impl From<VectorsU32Init> for VectorsU32 {
        fn from(data: VectorsU32Init) -> Self {
            data.const_into()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsI32 {
        /// size: 8, offset: 0x0, type: `vec2<i32>`
        pub a: [i32; 2],
        pub _pad_a: [u8; 0x10 - core::mem::size_of::<[i32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<i32>`
        pub b: [i32; 4],
        /// size: 16, offset: 0x20, type: `vec4<i32>`
        pub c: [i32; 4],
    }
    impl VectorsI32 {
        pub const fn new(a: [i32; 2], b: [i32; 4], c: [i32; 4]) -> Self {
            Self {
                a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[i32; 2]>()],
                b,
                c,
            }
        }
    }
    unsafe impl bytemuck::Zeroable for VectorsI32 {}
    unsafe impl bytemuck::Pod for VectorsI32 {}
    const _: () = {
        assert!(std::mem::offset_of!(VectorsI32, a) == 0);
        assert!(std::mem::offset_of!(VectorsI32, b) == 16);
        assert!(std::mem::offset_of!(VectorsI32, c) == 32);
        assert!(std::mem::size_of:: < VectorsI32 > () == 48);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsI32Init {
        pub a: [i32; 2],
        pub b: [i32; 4],
        pub c: [i32; 4],
    }
    impl VectorsI32Init {
        pub const fn const_into(&self) -> VectorsI32 {
            VectorsI32 {
                a: self.a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[i32; 2]>()],
                b: self.b,
                c: self.c,
            }
        }
    }
    impl From<VectorsI32Init> for VectorsI32 {
        fn from(data: VectorsI32Init) -> Self {
            data.const_into()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsF32 {
        /// size: 8, offset: 0x0, type: `vec2<f32>`
        pub a: [f32; 2],
        pub _pad_a: [u8; 0x10 - core::mem::size_of::<[f32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub b: glam::Vec3A,
        /// size: 16, offset: 0x20, type: `vec4<f32>`
        pub c: glam::Vec4,
    }
    impl VectorsF32 {
        pub const fn new(a: [f32; 2], b: glam::Vec3A, c: glam::Vec4) -> Self {
            Self {
                a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[f32; 2]>()],
                b,
                c,
            }
        }
    }
    unsafe impl bytemuck::Zeroable for VectorsF32 {}
    unsafe impl bytemuck::Pod for VectorsF32 {}
    const _: () = {
        assert!(std::mem::offset_of!(VectorsF32, a) == 0);
        assert!(std::mem::offset_of!(VectorsF32, b) == 16);
        assert!(std::mem::offset_of!(VectorsF32, c) == 32);
        assert!(std::mem::size_of:: < VectorsF32 > () == 48);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VectorsF32Init {
        pub a: [f32; 2],
        pub b: glam::Vec3A,
        pub c: glam::Vec4,
    }
    impl VectorsF32Init {
        pub const fn const_into(&self) -> VectorsF32 {
            VectorsF32 {
                a: self.a,
                _pad_a: [0; 0x10 - core::mem::size_of::<[f32; 2]>()],
                b: self.b,
                c: self.c,
            }
        }
    }
    impl From<VectorsF32Init> for VectorsF32 {
        fn from(data: VectorsF32Init) -> Self {
            data.const_into()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct MatricesF32 {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub a: glam::Mat4,
        /// size: 64, offset: 0x40, type: `mat4x3<f32>`
        pub b: [[f32; 4]; 4],
        /// size: 32, offset: 0x80, type: `mat4x2<f32>`
        pub c: [[f32; 2]; 4],
        /// size: 48, offset: 0xA0, type: `mat3x4<f32>`
        pub d: [[f32; 4]; 3],
        /// size: 48, offset: 0xD0, type: `mat3x3<f32>`
        pub e: glam::Mat3A,
        /// size: 24, offset: 0x100, type: `mat3x2<f32>`
        pub f: [[f32; 2]; 3],
        pub _pad_f: [u8; 0x20 - core::mem::size_of::<[[f32; 2]; 3]>()],
        /// size: 32, offset: 0x120, type: `mat2x4<f32>`
        pub g: [[f32; 4]; 2],
        /// size: 32, offset: 0x140, type: `mat2x3<f32>`
        pub h: [[f32; 4]; 2],
        /// size: 16, offset: 0x160, type: `mat2x2<f32>`
        pub i: [[f32; 2]; 2],
    }
    impl MatricesF32 {
        pub const fn new(
            a: glam::Mat4,
            b: [[f32; 4]; 4],
            c: [[f32; 2]; 4],
            d: [[f32; 4]; 3],
            e: glam::Mat3A,
            f: [[f32; 2]; 3],
            g: [[f32; 4]; 2],
            h: [[f32; 4]; 2],
            i: [[f32; 2]; 2],
        ) -> Self {
            Self {
                a,
                b,
                c,
                d,
                e,
                f,
                _pad_f: [0; 0x20 - core::mem::size_of::<[[f32; 2]; 3]>()],
                g,
                h,
                i,
            }
        }
    }
    unsafe impl bytemuck::Zeroable for MatricesF32 {}
    unsafe impl bytemuck::Pod for MatricesF32 {}
    const _: () = {
        assert!(std::mem::offset_of!(MatricesF32, a) == 0);
        assert!(std::mem::offset_of!(MatricesF32, b) == 64);
        assert!(std::mem::offset_of!(MatricesF32, c) == 128);
        assert!(std::mem::offset_of!(MatricesF32, d) == 160);
        assert!(std::mem::offset_of!(MatricesF32, e) == 208);
        assert!(std::mem::offset_of!(MatricesF32, f) == 256);
        assert!(std::mem::offset_of!(MatricesF32, g) == 288);
        assert!(std::mem::offset_of!(MatricesF32, h) == 320);
        assert!(std::mem::offset_of!(MatricesF32, i) == 352);
        assert!(std::mem::size_of:: < MatricesF32 > () == 368);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct MatricesF32Init {
        pub a: glam::Mat4,
        pub b: [[f32; 4]; 4],
        pub c: [[f32; 2]; 4],
        pub d: [[f32; 4]; 3],
        pub e: glam::Mat3A,
        pub f: [[f32; 2]; 3],
        pub g: [[f32; 4]; 2],
        pub h: [[f32; 4]; 2],
        pub i: [[f32; 2]; 2],
    }
    impl MatricesF32Init {
        pub const fn const_into(&self) -> MatricesF32 {
            MatricesF32 {
                a: self.a,
                b: self.b,
                c: self.c,
                d: self.d,
                e: self.e,
                f: self.f,
                _pad_f: [0; 0x20 - core::mem::size_of::<[[f32; 2]; 3]>()],
                g: self.g,
                h: self.h,
                i: self.i,
            }
        }
    }
    impl From<MatricesF32Init> for MatricesF32 {
        fn from(data: MatricesF32Init) -> Self {
            data.const_into()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct StaticArrays {
        /// size: 20, offset: 0x0, type: `array<u32, 5>`
        pub a: [u32; 5],
        pub _pad_a: [u8; 0x14 - core::mem::size_of::<[u32; 5]>()],
        /// size: 12, offset: 0x14, type: `array<f32, 3>`
        pub b: [f32; 3],
        pub _pad_b: [u8; 0xC - core::mem::size_of::<[f32; 3]>()],
        /// size: 32768, offset: 0x20, type: `array<mat4x4<f32>, 512>`
        pub c: [glam::Mat4; 512],
        pub _pad_c: [u8; 0x8000 - core::mem::size_of::<[glam::Mat4; 512]>()],
        /// size: 64, offset: 0x8020, type: `array<vec3<f32>, 4>`
        pub d: [glam::Vec3A; 4],
        pub _pad_d: [u8; 0x40 - core::mem::size_of::<[glam::Vec3A; 4]>()],
    }
    impl StaticArrays {
        pub const fn new(
            a: [u32; 5],
            b: [f32; 3],
            c: [glam::Mat4; 512],
            d: [glam::Vec3A; 4],
        ) -> Self {
            Self {
                a,
                _pad_a: [0; 0x14 - core::mem::size_of::<[u32; 5]>()],
                b,
                _pad_b: [0; 0xC - core::mem::size_of::<[f32; 3]>()],
                c,
                _pad_c: [0; 0x8000 - core::mem::size_of::<[glam::Mat4; 512]>()],
                d,
                _pad_d: [0; 0x40 - core::mem::size_of::<[glam::Vec3A; 4]>()],
            }
        }
    }
    unsafe impl bytemuck::Zeroable for StaticArrays {}
    unsafe impl bytemuck::Pod for StaticArrays {}
    const _: () = {
        assert!(std::mem::offset_of!(StaticArrays, a) == 0);
        assert!(std::mem::offset_of!(StaticArrays, b) == 20);
        assert!(std::mem::offset_of!(StaticArrays, c) == 32);
        assert!(std::mem::offset_of!(StaticArrays, d) == 32800);
        assert!(std::mem::size_of:: < StaticArrays > () == 32864);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct StaticArraysInit {
        pub a: [u32; 5],
        pub b: [f32; 3],
        pub c: [glam::Mat4; 512],
        pub d: [glam::Vec3A; 4],
    }
    impl StaticArraysInit {
        pub const fn const_into(&self) -> StaticArrays {
            StaticArrays {
                a: self.a,
                _pad_a: [0; 0x14 - core::mem::size_of::<[u32; 5]>()],
                b: self.b,
                _pad_b: [0; 0xC - core::mem::size_of::<[f32; 3]>()],
                c: self.c,
                _pad_c: [0; 0x8000 - core::mem::size_of::<[glam::Mat4; 512]>()],
                d: self.d,
                _pad_d: [0; 0x40 - core::mem::size_of::<[glam::Vec3A; 4]>()],
            }
        }
    }
    impl From<StaticArraysInit> for StaticArrays {
        fn from(data: StaticArraysInit) -> Self {
            data.const_into()
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Nested {
        /// size: 368, offset: 0x0, type: `struct`
        pub a: _root::types::MatricesF32,
        /// size: 48, offset: 0x170, type: `struct`
        pub b: _root::types::VectorsF32,
    }
    pub const fn Nested(
        a: _root::types::MatricesF32,
        b: _root::types::VectorsF32,
    ) -> Nested {
        Nested { a, b }
    }
    unsafe impl bytemuck::Zeroable for Nested {}
    unsafe impl bytemuck::Pod for Nested {}
    const _: () = {
        assert!(std::mem::offset_of!(Nested, a) == 0);
        assert!(std::mem::offset_of!(Nested, b) == 368);
        assert!(std::mem::size_of:: < Nested > () == 416);
    };
}
pub mod testbed {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 16, offset: 0x0, type: `vec4<f32>`
        pub color_rgb: glam::Vec4,
        /// size: 12, offset: 0x10, type: `struct`
        pub scalars: _root::types::Scalars,
        pub _pad_scalars: [u8; 0x10 - core::mem::size_of::<_root::types::Scalars>()],
    }
    pub const fn Uniforms(
        color_rgb: glam::Vec4,
        scalars: _root::types::Scalars,
    ) -> Uniforms {
        Uniforms {
            color_rgb,
            scalars,
            _pad_scalars: [0; 0x10 - core::mem::size_of::<_root::types::Scalars>()],
        }
    }
    unsafe impl bytemuck::Zeroable for Uniforms {}
    unsafe impl bytemuck::Pod for Uniforms {}
    const _: () = {
        assert!(std::mem::offset_of!(Uniforms, color_rgb) == 0);
        assert!(std::mem::offset_of!(Uniforms, scalars) == 16);
        assert!(std::mem::size_of:: < Uniforms > () == 32);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub color_rgb: glam::Vec4,
        pub scalars: _root::types::Scalars,
    }
    impl UniformsInit {
        pub const fn const_into(&self) -> Uniforms {
            Uniforms {
                color_rgb: self.color_rgb,
                scalars: self.scalars,
                _pad_scalars: [0; 0x10 - core::mem::size_of::<_root::types::Scalars>()],
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.const_into()
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VertexInput {
        pub position: glam::Vec3A,
    }
    pub const fn VertexInput(position: glam::Vec3A) -> VertexInput {
        VertexInput { position }
    }
    unsafe impl bytemuck::Zeroable for VertexInput {}
    unsafe impl bytemuck::Pod for VertexInput {}
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct BindGroup0(wgpu::BindGroup);
        #[derive(Debug)]
        pub struct BindGroupLayout0<'a> {
            pub color_texture: &'a wgpu::TextureView,
            pub color_sampler: &'a wgpu::Sampler,
        }
        const LAYOUT_DESCRIPTOR0: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Float {
                            filterable: true,
                        },
                        view_dimension: wgpu::TextureViewDimension::D2,
                        multisampled: false,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
        };
        impl BindGroup0 {
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: BindGroupLayout0,
            ) -> Self {
                let bind_group_layout = device
                    .create_bind_group_layout(&LAYOUT_DESCRIPTOR0);
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            layout: &bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    resource: wgpu::BindingResource::TextureView(
                                        bindings.color_texture,
                                    ),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Sampler(
                                        bindings.color_sampler,
                                    ),
                                },
                            ],
                            label: None,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct BindGroup1(wgpu::BindGroup);
        #[derive(Debug)]
        pub struct BindGroupLayout1<'a> {
            pub ONE: wgpu::BufferBinding<'a>,
            pub uniforms: wgpu::BufferBinding<'a>,
        }
        const LAYOUT_DESCRIPTOR1: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        impl BindGroup1 {
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: BindGroupLayout1,
            ) -> Self {
                let bind_group_layout = device
                    .create_bind_group_layout(&LAYOUT_DESCRIPTOR1);
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            layout: &bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Buffer(bindings.ONE),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    resource: wgpu::BindingResource::Buffer(bindings.uniforms),
                                },
                            ],
                            label: None,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
                render_pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct BindGroup2(wgpu::BindGroup);
        #[derive(Debug)]
        pub struct BindGroupLayout2<'a> {
            pub rts: wgpu::BufferBinding<'a>,
            pub a: wgpu::BufferBinding<'a>,
            pub b: wgpu::BufferBinding<'a>,
            pub c: wgpu::BufferBinding<'a>,
            pub d: wgpu::BufferBinding<'a>,
            pub f: wgpu::BufferBinding<'a>,
            pub h: wgpu::BufferBinding<'a>,
            pub i: wgpu::BufferBinding<'a>,
        }
        const LAYOUT_DESCRIPTOR2: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 4,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 5,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 6,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 8,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 9,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        impl BindGroup2 {
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&LAYOUT_DESCRIPTOR2)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: BindGroupLayout2,
            ) -> Self {
                let bind_group_layout = device
                    .create_bind_group_layout(&LAYOUT_DESCRIPTOR2);
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            layout: &bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Buffer(bindings.rts),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 2,
                                    resource: wgpu::BindingResource::Buffer(bindings.a),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 3,
                                    resource: wgpu::BindingResource::Buffer(bindings.b),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 4,
                                    resource: wgpu::BindingResource::Buffer(bindings.c),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 5,
                                    resource: wgpu::BindingResource::Buffer(bindings.d),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 6,
                                    resource: wgpu::BindingResource::Buffer(bindings.f),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 8,
                                    resource: wgpu::BindingResource::Buffer(bindings.h),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 9,
                                    resource: wgpu::BindingResource::Buffer(bindings.i),
                                },
                            ],
                            label: None,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
                render_pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct BindGroups<'a> {
            pub bind_group0: &'a BindGroup0,
            pub bind_group1: &'a BindGroup1,
            pub bind_group2: &'a BindGroup2,
        }
        impl<'a> BindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::RenderPass<'a>) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::RenderPass<'a>,
        bind_group0: &'a bind_groups::BindGroup0,
        bind_group1: &'a bind_groups::BindGroup1,
        bind_group2: &'a bind_groups::BindGroup2,
    ) {
        bind_group0.set(pass);
        bind_group1.set(pass);
        bind_group2.set(pass);
    }
    impl VertexInput {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(VertexInput, position) as u64,
                shader_location: 0,
            },
        ];
        pub const fn vertex_buffer_layout(
            step_mode: wgpu::VertexStepMode,
        ) -> wgpu::VertexBufferLayout<'static> {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<VertexInput>() as u64,
                step_mode,
                attributes: &VertexInput::VERTEX_ATTRIBUTES,
            }
        }
    }
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        entry_point: &'static str,
        buffers: [wgpu::VertexBufferLayout<'static>; N],
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: entry.entry_point,
            buffers: &entry.buffers,
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: None,
                    bind_group_layouts: &[
                        &bind_groups::BindGroup0::get_bind_group_layout(device),
                        &bind_groups::BindGroup1::get_bind_group_layout(device),
                        &bind_groups::BindGroup2::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn init_composer() -> naga_oil::compose::Composer {
        let mut composer = naga_oil::compose::Composer::default();
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("shader/../more-shader-files/reachme.wgsl"),
                file_path: "shader/../more-shader-files/reachme.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                as_name: Some("\"../more-shader-files/reachme\"".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("shader/types.wgsl"),
                file_path: "shader/types.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                as_name: Some("types".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        composer
    }
    pub fn make_naga_module(
        composer: &mut naga_oil::compose::Composer,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("shader/testbed.wgsl"),
                file_path: "shader/testbed.wgsl",
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn naga_module_to_string(module: &wgpu::naga::Module) -> String {
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module);
        let info = info.unwrap();
        wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source")
    }
    pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {
        let mut composer = init_composer();
        let module = make_naga_module(&mut composer);
        let source = naga_module_to_string(&module);
        let source = std::borrow::Cow::Owned(source);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: None,
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod triangle {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 16, offset: 0x0, type: `vec4<f32>`
        pub color_rgb: glam::Vec4,
    }
    pub const fn Uniforms(color_rgb: glam::Vec4) -> Uniforms {
        Uniforms { color_rgb }
    }
    unsafe impl bytemuck::Zeroable for Uniforms {}
    unsafe impl bytemuck::Pod for Uniforms {}
    const _: () = {
        assert!(std::mem::offset_of!(Uniforms, color_rgb) == 0);
        assert!(std::mem::size_of:: < Uniforms > () == 16);
    };
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VertexInput {
        pub position: glam::Vec3A,
    }
    pub const fn VertexInput(position: glam::Vec3A) -> VertexInput {
        VertexInput { position }
    }
    unsafe impl bytemuck::Zeroable for VertexInput {}
    unsafe impl bytemuck::Pod for VertexInput {}
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct BindGroup0(wgpu::BindGroup);
        #[derive(Debug)]
        pub struct BindGroupLayout0<'a> {
            pub color_texture: &'a wgpu::TextureView,
            pub color_sampler: &'a wgpu::Sampler,
        }
        const LAYOUT_DESCRIPTOR0: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Float {
                            filterable: true,
                        },
                        view_dimension: wgpu::TextureViewDimension::D2,
                        multisampled: false,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
        };
        impl BindGroup0 {
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: BindGroupLayout0,
            ) -> Self {
                let bind_group_layout = device
                    .create_bind_group_layout(&LAYOUT_DESCRIPTOR0);
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            layout: &bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    resource: wgpu::BindingResource::TextureView(
                                        bindings.color_texture,
                                    ),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Sampler(
                                        bindings.color_sampler,
                                    ),
                                },
                            ],
                            label: None,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct BindGroup1(wgpu::BindGroup);
        #[derive(Debug)]
        pub struct BindGroupLayout1<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
        }
        const LAYOUT_DESCRIPTOR1: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        impl BindGroup1 {
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: BindGroupLayout1,
            ) -> Self {
                let bind_group_layout = device
                    .create_bind_group_layout(&LAYOUT_DESCRIPTOR1);
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            layout: &bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    resource: wgpu::BindingResource::Buffer(bindings.uniforms),
                                },
                            ],
                            label: None,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
                render_pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct BindGroups<'a> {
            pub bind_group0: &'a BindGroup0,
            pub bind_group1: &'a BindGroup1,
        }
        impl<'a> BindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::RenderPass<'a>) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::RenderPass<'a>,
        bind_group0: &'a bind_groups::BindGroup0,
        bind_group1: &'a bind_groups::BindGroup1,
    ) {
        bind_group0.set(pass);
        bind_group1.set(pass);
    }
    impl VertexInput {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(VertexInput, position) as u64,
                shader_location: 0,
            },
        ];
        pub const fn vertex_buffer_layout(
            step_mode: wgpu::VertexStepMode,
        ) -> wgpu::VertexBufferLayout<'static> {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<VertexInput>() as u64,
                step_mode,
                attributes: &VertexInput::VERTEX_ATTRIBUTES,
            }
        }
    }
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        entry_point: &'static str,
        buffers: [wgpu::VertexBufferLayout<'static>; N],
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: entry.entry_point,
            buffers: &entry.buffers,
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: None,
                    bind_group_layouts: &[
                        &bind_groups::BindGroup0::get_bind_group_layout(device),
                        &bind_groups::BindGroup1::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn init_composer() -> naga_oil::compose::Composer {
        let mut composer = naga_oil::compose::Composer::default();
        composer
    }
    pub fn make_naga_module(
        composer: &mut naga_oil::compose::Composer,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("shader/triangle.wgsl"),
                file_path: "shader/triangle.wgsl",
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn naga_module_to_string(module: &wgpu::naga::Module) -> String {
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module);
        let info = info.unwrap();
        wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source")
    }
    pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {
        let mut composer = init_composer();
        let module = make_naga_module(&mut composer);
        let source = naga_module_to_string(&module);
        let source = std::borrow::Cow::Owned(source);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: None,
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
